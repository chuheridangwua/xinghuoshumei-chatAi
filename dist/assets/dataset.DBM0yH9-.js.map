{"version":3,"file":"dataset.DBM0yH9-.js","sources":["../../static/app/api/config.js","../../static/app/api/request.js","../../static/app/api/dataset.js"],"sourcesContent":["/**\n * API配置文件\n * 统一管理API的基础URL和密钥\n */\n\n/**\n * API基础配置\n */\nexport const API_CONFIG = {\n    baseURL: '/api/v1', // 使用相对路径，通过Vite代理转发\n    apiKey: 'app-JUQYZhaSvAhw9YtuhOCo66A6',  // Dify API 密钥\n    workflowApiKey: 'app-6aRhLAp4zAppCJus5ViMgOsh',  // 工作流API密钥（用于标题生成）\n    datasetApiKey: 'dataset-NU4Kg7Wtm1616AOnxnRAeFct'  // 知识库API密钥\n};\n\n/**\n * 创建API URL\n * @param {String} path - API路径\n * @param {String} customBaseUrl - 可选的自定义基础URL，默认使用API_CONFIG.baseURL\n * @returns {URL} 创建的URL对象\n */\nexport const createApiUrl = (path, customBaseUrl) => {\n    const baseUrl = customBaseUrl || API_CONFIG.baseURL;\n    const urlString = `${baseUrl}${path}`;\n    const isAbsoluteUrl = urlString.startsWith('http://') || urlString.startsWith('https://');\n    return isAbsoluteUrl ? new URL(urlString) : new URL(urlString, window.location.origin);\n};\n\n/**\n * 获取API配置\n * @returns {Object} API配置对象\n */\nexport const getApiConfig = () => {\n    return API_CONFIG;\n};\n\n/**\n * 重设API配置\n * @param {Object} newConfig - 新的配置对象\n */\nexport const updateAPIConfig = (newConfig) => {\n    if (newConfig.baseURL) {\n        API_CONFIG.baseURL = newConfig.baseURL;\n    }\n    \n    if (newConfig.apiKey) {\n        API_CONFIG.apiKey = newConfig.apiKey;\n    }\n    \n    if (newConfig.workflowApiKey) {\n        API_CONFIG.workflowApiKey = newConfig.workflowApiKey;\n    }\n\n    if (newConfig.datasetBaseURL) {\n        API_CONFIG.datasetBaseURL = newConfig.datasetBaseURL;\n    }\n    \n    if (newConfig.datasetApiKey) {\n        API_CONFIG.datasetApiKey = newConfig.datasetApiKey;\n    }\n\n    console.log('API配置已更新:', API_CONFIG);\n    return API_CONFIG;\n};","/**\r\n * 请求状态管理和中断处理的公共函数\r\n */\r\n\r\n// 导入API配置\r\nimport { API_CONFIG } from './config.js';\r\n\r\n/**\r\n * 创建请求控制器\r\n * @returns {Object} 请求控制对象，包含控制器和中断函数\r\n */\r\nexport const createRequestController = () => {\r\n    const controller = new AbortController();\r\n    const signal = controller.signal;\r\n    \r\n    // 创建中断函数\r\n    const abortRequest = () => {\r\n        // 只有在未中断的情况下才执行中断操作\r\n        if (!controller.signal.aborted) {\r\n            try {\r\n                console.log('执行请求中断操作');\r\n                controller.abort();\r\n                console.log('请求中断完成');\r\n            } catch (error) {\r\n                console.error('中断请求时出错:', error);\r\n            }\r\n        } else {\r\n            console.log('请求已经被中断，不再重复执行');\r\n        }\r\n    };\r\n    \r\n    return {\r\n        controller,\r\n        signal,\r\n        abortRequest\r\n    };\r\n};\r\n\r\n/**\r\n * 创建超时保护\r\n * @param {Function} abortFunction - 中断函数\r\n * @param {number} timeout - 超时时间（毫秒）\r\n * @returns {number} 超时计时器ID\r\n */\r\nexport const createTimeoutProtection = (abortFunction, timeout = 30000) => {\r\n    return setTimeout(() => {\r\n        if (typeof abortFunction === 'function') {\r\n            abortFunction();\r\n        }\r\n    }, timeout);\r\n};\r\n\r\n/**\r\n * 处理请求中断后的UI状态更新\r\n * @param {Object} lastMessage - 最后一条助手消息\r\n * @param {Object} stateControls - 状态控制对象，包含loading和isStreamLoad\r\n */\r\nexport const handleRequestAbort = (lastMessage, stateControls) => {\r\n    const { loading, isStreamLoad } = stateControls;\r\n    \r\n    // 重置加载状态\r\n    if (loading && typeof loading.value !== 'undefined') {\r\n        loading.value = false;\r\n    }\r\n    \r\n    if (isStreamLoad && typeof isStreamLoad.value !== 'undefined') {\r\n        isStreamLoad.value = false;\r\n    }\r\n    \r\n    // 处理消息状态\r\n    if (lastMessage && lastMessage.role === 'assistant') {\r\n        // 如果消息为空，添加一个提示\r\n        if (!lastMessage.content || lastMessage.content === '') {\r\n            lastMessage.content = '回复已中断';\r\n        } else if (!lastMessage.content.includes('[已中断]')) {\r\n            lastMessage.content += ' [已中断]';\r\n        }\r\n\r\n        // 如果有思考内容并且是\"思考中...\"，则更新为已中断\r\n        if (lastMessage.reasoning === '思考中...') {\r\n            lastMessage.reasoning = '思考过程已中断';\r\n        } else if (lastMessage.reasoning && !lastMessage.reasoning.includes('已中断')) {\r\n            lastMessage.reasoning += ' [已中断]';\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * 处理请求错误\r\n * @param {Object} error - 错误对象\r\n * @param {Object} lastMessage - 最后一条助手消息\r\n * @param {Object} stateControls - 状态控制对象\r\n * @returns {boolean} 是否为中断错误\r\n */\r\nexport const handleRequestError = (error, lastMessage, stateControls) => {\r\n    const { loading, isStreamLoad } = stateControls;\r\n    const errorMessage = error?.message || error || '请求失败';\r\n    \r\n    console.log('处理请求错误:', errorMessage);\r\n    \r\n    // 重置加载状态\r\n    if (loading && typeof loading.value !== 'undefined') {\r\n        loading.value = false;\r\n    }\r\n    \r\n    if (isStreamLoad && typeof isStreamLoad.value !== 'undefined') {\r\n        isStreamLoad.value = false;\r\n    }\r\n    \r\n    // 检查是否是中断导致的错误或消息通道关闭错误\r\n    const isAborted = \r\n        errorMessage.includes('abort') || \r\n        errorMessage.includes('中断') || \r\n        errorMessage.includes('cancel') ||\r\n        errorMessage.includes('BodyStreamBuffer was aborted') ||\r\n        errorMessage.includes('message channel closed') ||\r\n        errorMessage.includes('listener indicated an asynchronous response') ||\r\n        error?.name === 'AbortError';\r\n    \r\n    if (isAborted) {\r\n        // 处理中断状态\r\n        if (lastMessage) {\r\n            if (!lastMessage.content || lastMessage.content === '') {\r\n                lastMessage.content = '回复已中断';\r\n            } else if (!lastMessage.content.includes('[已中断]')) {\r\n                lastMessage.content += ' [已中断]';\r\n            }\r\n            \r\n            // 处理思考状态\r\n            if (lastMessage.reasoning === '思考中...') {\r\n                lastMessage.reasoning = '思考过程已中断';\r\n            } else if (lastMessage.reasoning && !lastMessage.reasoning.includes('已中断')) {\r\n                lastMessage.reasoning += ' [已中断]';\r\n            }\r\n        }\r\n    } else if (lastMessage) {\r\n        // 处理错误状态\r\n        lastMessage.role = 'error';\r\n        lastMessage.content = errorMessage;\r\n    }\r\n    \r\n    return isAborted;\r\n};\r\n\r\n/**\r\n * 处理请求完成\r\n * @param {boolean} isOk - 请求是否成功\r\n * @param {string} msg - 完成消息\r\n * @param {Object} lastMessage - 最后一条助手消息\r\n * @param {Object} stateControls - 状态控制对象\r\n * @param {Object} controllers - 控制器对象\r\n */\r\nexport const handleRequestComplete = (isOk, msg, lastMessage, stateControls, controllers) => {\r\n    const { loading, isStreamLoad } = stateControls || {};\r\n    const { timeoutId, fetchCancel } = controllers || {};\r\n    \r\n    // 清除超时保护\r\n    if (timeoutId) {\r\n        clearTimeout(timeoutId);\r\n    }\r\n    \r\n    // 检查是否是中断导致的完成\r\n    const isAborted = !isOk && (msg && (\r\n        msg.includes('abort') || \r\n        msg.includes('中断') || \r\n        msg.includes('cancel') ||\r\n        msg.includes('BodyStreamBuffer was aborted') ||\r\n        msg.includes('message channel closed') ||\r\n        msg.includes('listener indicated an asynchronous response')\r\n    ));\r\n    \r\n    // 确保lastMessage存在再进行操作\r\n    if (lastMessage) {\r\n        if (isAborted) {\r\n            if (!lastMessage.content || lastMessage.content === '') {\r\n                lastMessage.content = '回复已中断';\r\n            } else if (!lastMessage.content.includes('[已中断]')) {\r\n                lastMessage.content += ' [已中断]';\r\n            }\r\n        } else if (!isOk || !lastMessage.content) {\r\n            lastMessage.role = 'error';\r\n            lastMessage.content = msg || '请求失败';\r\n        }\r\n    }\r\n    \r\n    // 重置状态\r\n    if (isStreamLoad && typeof isStreamLoad?.value !== 'undefined') {\r\n        isStreamLoad.value = false;\r\n    }\r\n    \r\n    if (loading && typeof loading?.value !== 'undefined') {\r\n        loading.value = false;\r\n    }\r\n    \r\n    // 清空中断函数，防止内存泄漏\r\n    if (fetchCancel && typeof fetchCancel?.value !== 'undefined') {\r\n        // 确保中断函数存在且未执行过时再尝试设置为null\r\n        try {\r\n            fetchCancel.value = null;\r\n        } catch (error) {\r\n            console.warn('清空中断函数时出错:', error);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * 向服务器发送停止流式响应的请求\r\n * @param {String} taskId - 任务ID\r\n * @param {String} userId - 用户ID\r\n * @returns {Promise<boolean>} 是否成功停止\r\n */\r\nexport const stopStreamResponse = async (taskId, userId) => {\r\n    if (!taskId || !userId) {\r\n        console.error('[Stream Stop] 停止响应失败: taskId或userId不能为空', { taskId, userId });\r\n        return false;\r\n    }\r\n\r\n    console.log('[Stream Stop] 尝试停止流式响应', { taskId, userId });\r\n\r\n    try {\r\n        // 使用统一的API配置\r\n        const baseURL = API_CONFIG.baseURL;\r\n        const apiKey = API_CONFIG.apiKey;\r\n        \r\n        console.log('[Stream Stop] 发送停止请求到:', `${baseURL}/chat-messages/${taskId}/stop`);\r\n        \r\n        const response = await fetch(`${baseURL}/chat-messages/${taskId}/stop`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'Authorization': `Bearer ${apiKey}`\r\n            },\r\n            body: JSON.stringify({\r\n                user: userId\r\n            })\r\n        });\r\n        \r\n        const result = await response.json();\r\n        \r\n        if (response.ok) {\r\n            console.log('[Stream Stop] 流式响应已成功停止', { \r\n                status: response.status,\r\n                result: result \r\n            });\r\n            return true;\r\n        } else {\r\n            console.error('[Stream Stop] 停止响应请求失败:', { \r\n                status: response.status, \r\n                result: result \r\n            });\r\n            return false;\r\n        }\r\n    } catch (error) {\r\n        console.error('[Stream Stop] 停止响应请求错误:', error);\r\n        return false;\r\n    }\r\n};","/**\n * 知识库管理API\n * 提供对知识库的创建、查询、更新和删除操作\n */\n\n// 导入请求处理工具和API配置\nimport { createRequestController, handleRequestError, handleRequestComplete } from './request.js';\nimport { API_CONFIG, createApiUrl } from './config.js';\n\n/**\n * 获取知识库API URL\n * @param {String} path - API路径\n * @returns {String} 完整的API URL\n */\nconst getDatasetApiUrl = (path) => {\n    return createApiUrl(path, API_CONFIG.baseURL).toString();\n};\n\n/**\n * 获取知识库API请求头\n * @returns {Object} 请求头对象\n */\nconst getDatasetApiHeaders = () => {\n    return {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_CONFIG.datasetApiKey}`\n    };\n};\n\n/**\n * 获取知识库列表\n * @param {Object} options - 查询选项\n * @param {Number} options.page - 页码，从1开始\n * @param {Number} options.limit - 每页数量\n * @returns {Promise<Object>} 包含知识库列表的响应对象\n */\nexport const getDatasetList = async (options = {}) => {\n    const { page = 1, limit = 20 } = options;\n    const { signal } = createRequestController();\n\n    try {\n        const url = new URL(getDatasetApiUrl('/datasets'));\n        url.searchParams.append('page', page);\n        url.searchParams.append('limit', limit);\n\n        const response = await fetch(url.toString(), {\n            method: 'GET',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`获取知识库列表失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('获取知识库列表错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 创建知识库\n * @param {Object} datasetData - 知识库数据\n * @param {String} datasetData.name - 知识库名称\n * @param {String} datasetData.description - 知识库描述\n * @param {String} datasetData.indexing_technique - 索引技术，支持\"high_quality\"或\"economy\"\n * @param {String} datasetData.permission - 权限，支持\"only_me\"或\"all_team_members\"或\"partial_members\"\n * @param {String} datasetData.provider - 数据提供者，支持\"vendor\"或\"external\"\n * @returns {Promise<Object>} 创建的知识库对象\n */\nexport const createDataset = async (datasetData) => {\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl('/datasets'), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify(datasetData),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`创建知识库失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('创建知识库错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 更新知识库\n * @param {String} datasetId - 知识库ID\n * @param {Object} datasetData - 要更新的知识库数据\n * @returns {Promise<Object>} 更新后的知识库对象\n */\nexport const updateDataset = async (datasetId, datasetData) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}`), {\n            method: 'PATCH',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify(datasetData),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`更新知识库失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('更新知识库错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 删除知识库\n * @param {String} datasetId - 知识库ID\n * @returns {Promise<Object>} 删除结果\n */\nexport const deleteDataset = async (datasetId) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}`), {\n            method: 'DELETE',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`删除知识库失败: ${response.status}`);\n        }\n\n        // 检查响应内容类型和长度\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            const text = await response.text();\n            // 只有当响应文本不为空时才尝试解析JSON\n            return text ? JSON.parse(text) : { success: true };\n        } else {\n            // 非JSON响应，返回成功状态\n            return { success: true };\n        }\n    } catch (error) {\n        console.error('删除知识库错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 获取知识库文档列表\n * @param {String} datasetId - 知识库ID\n * @param {Object} options - 查询选项\n * @param {Number} options.page - 页码，从1开始\n * @param {Number} options.limit - 每页数量\n * @param {String} options.keyword - 搜索关键词(可选)\n * @returns {Promise<Object>} 包含文档列表的响应对象\n */\nexport const getDocumentList = async (datasetId, options = {}) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { page = 1, limit = 20, keyword } = options;\n    const { signal } = createRequestController();\n\n    try {\n        const url = new URL(getDatasetApiUrl(`/datasets/${datasetId}/documents`));\n        url.searchParams.append('page', page);\n        url.searchParams.append('limit', limit);\n        if (keyword) {\n            url.searchParams.append('keyword', keyword);\n        }\n\n        const response = await fetch(url.toString(), {\n            method: 'GET',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`获取文档列表失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('获取文档列表错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 通过文本创建文档\n * @param {String} datasetId - 知识库ID\n * @param {Object} documentData - 文档数据\n * @param {String} documentData.name - 文档名称\n * @param {String} documentData.text - 文档文本内容\n * @param {String} documentData.indexing_technique - 索引方式\n * @param {String} documentData.doc_form - 索引内容的形式(可选)\n * @param {String} documentData.doc_language - 文档语言(Q&A模式下)\n * @param {Object} documentData.process_rule - 处理规则\n * @returns {Promise<Object>} 创建的文档对象\n */\nexport const createDocumentByText = async (datasetId, documentData) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/document/create-by-text`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify(documentData),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`通过文本创建文档失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('通过文本创建文档错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 通过文件创建文档\n * @param {String} datasetId - 知识库ID\n * @param {FormData} formData - 包含文件和元数据的表单数据\n * @returns {Promise<Object>} 上传结果\n */\nexport const createDocumentByFile = async (datasetId, formData) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/document/create-by-file`), {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${API_CONFIG.datasetApiKey}`\n            },\n            body: formData,\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`通过文件创建文档失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('通过文件创建文档错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 通过文本更新文档\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @param {Object} documentData - 文档数据\n * @returns {Promise<Object>} 更新结果\n */\nexport const updateDocumentByText = async (datasetId, documentId, documentData) => {\n    if (!datasetId || !documentId) {\n        throw new Error('知识库ID和文档ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}/update-by-text`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify(documentData),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`通过文本更新文档失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('通过文本更新文档错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 通过文件更新文档\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @param {FormData} formData - 包含文件和元数据的表单数据\n * @returns {Promise<Object>} 更新结果\n */\nexport const updateDocumentByFile = async (datasetId, documentId, formData) => {\n    if (!datasetId || !documentId) {\n        throw new Error('知识库ID和文档ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}/update-by-file`), {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${API_CONFIG.datasetApiKey}`\n            },\n            body: formData,\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`通过文件更新文档失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('通过文件更新文档错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 获取文档索引状态（上传进度）\n * @param {String} datasetId - 知识库ID\n * @param {String} batch - 上传文档的批次号\n * @returns {Promise<Object>} 包含索引状态的响应对象\n */\nexport const getDocumentIndexingStatus = async (datasetId, batch) => {\n    if (!datasetId || !batch) {\n        throw new Error('知识库ID和批次号不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${batch}/indexing-status`), {\n            method: 'GET',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`获取文档索引状态失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('获取文档索引状态错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 删除文档\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @returns {Promise<Object>} 删除结果\n */\nexport const deleteDocument = async (datasetId, documentId) => {\n    if (!datasetId || !documentId) {\n        throw new Error('知识库ID和文档ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}`), {\n            method: 'DELETE',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`删除文档失败: ${response.status}`);\n        }\n\n        // 检查响应内容类型和长度\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            const text = await response.text();\n            // 只有当响应文本不为空时才尝试解析JSON\n            return text ? JSON.parse(text) : { success: true };\n        } else {\n            // 非JSON响应，返回成功状态\n            return { success: true };\n        }\n    } catch (error) {\n        console.error('删除文档错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 获取文档分段\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @param {Object} options - 查询选项\n * @param {String} options.keyword - 搜索关键词(可选)\n * @param {String} options.status - 分段状态(可选)\n * @returns {Promise<Object>} 包含分段列表的响应对象\n */\nexport const getDocumentSegments = async (datasetId, documentId, options = {}) => {\n    if (!datasetId || !documentId) {\n        throw new Error('知识库ID和文档ID不能为空');\n    }\n\n    const { keyword, status } = options;\n    const { signal } = createRequestController();\n\n    try {\n        const url = new URL(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}/segments`));\n        if (keyword) {\n            url.searchParams.append('keyword', keyword);\n        }\n        if (status) {\n            url.searchParams.append('status', status);\n        }\n\n        const response = await fetch(url.toString(), {\n            method: 'GET',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`获取文档分段失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('获取文档分段错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 新增文档分段\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @param {Array} segments - 分段数据数组\n * @returns {Promise<Object>} 创建结果\n */\nexport const createDocumentSegments = async (datasetId, documentId, segments) => {\n    if (!datasetId || !documentId) {\n        throw new Error('知识库ID和文档ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}/segments`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify({ segments }),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`创建文档分段失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('创建文档分段错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 更新文档分段\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @param {String} segmentId - 分段ID\n * @param {Object} segment - 分段数据\n * @returns {Promise<Object>} 更新结果\n */\nexport const updateDocumentSegment = async (datasetId, documentId, segmentId, segment) => {\n    if (!datasetId || !documentId || !segmentId) {\n        throw new Error('知识库ID、文档ID和分段ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}/segments/${segmentId}`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify({ segment }),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`更新文档分段失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('更新文档分段错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 删除文档分段\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @param {String} segmentId - 分段ID\n * @returns {Promise<Object>} 删除结果\n */\nexport const deleteDocumentSegment = async (datasetId, documentId, segmentId) => {\n    if (!datasetId || !documentId || !segmentId) {\n        throw new Error('知识库ID、文档ID和分段ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}/segments/${segmentId}`), {\n            method: 'DELETE',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`删除文档分段失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('删除文档分段错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 获取上传文件\n * @param {String} datasetId - 知识库ID\n * @param {String} documentId - 文档ID\n * @returns {Promise<Object>} 文件信息\n */\nexport const getUploadFile = async (datasetId, documentId) => {\n    if (!datasetId || !documentId) {\n        throw new Error('知识库ID和文档ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/${documentId}/upload-file`), {\n            method: 'GET',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`获取上传文件失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('获取上传文件错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 检索知识库\n * @param {String} datasetId - 知识库ID\n * @param {Object} retrievalParams - 检索参数\n * @returns {Promise<Object>} 检索结果\n */\nexport const retrieveDataset = async (datasetId, retrievalParams) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/retrieve`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify(retrievalParams),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`检索知识库失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('检索知识库错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 获取知识库元数据列表\n * @param {String} datasetId - 知识库ID\n * @returns {Promise<Object>} 元数据列表\n */\nexport const getDatasetMetadata = async (datasetId) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/metadata`), {\n            method: 'GET',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`获取知识库元数据列表失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('获取知识库元数据列表错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 添加元数据\n * @param {String} datasetId - 知识库ID\n * @param {Object} metadata - 元数据\n * @returns {Promise<Object>} 创建结果\n */\nexport const createDatasetMetadata = async (datasetId, metadata) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/metadata`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify(metadata),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`添加元数据失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('添加元数据错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 更新元数据\n * @param {String} datasetId - 知识库ID\n * @param {String} metadataId - 元数据ID\n * @param {Object} metadata - 更新数据\n * @returns {Promise<Object>} 更新结果\n */\nexport const updateDatasetMetadata = async (datasetId, metadataId, metadata) => {\n    if (!datasetId || !metadataId) {\n        throw new Error('知识库ID和元数据ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/metadata/${metadataId}`), {\n            method: 'PATCH',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify(metadata),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`更新元数据失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('更新元数据错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 删除元数据\n * @param {String} datasetId - 知识库ID\n * @param {String} metadataId - 元数据ID\n * @returns {Promise<Object>} 删除结果\n */\nexport const deleteDatasetMetadata = async (datasetId, metadataId) => {\n    if (!datasetId || !metadataId) {\n        throw new Error('知识库ID和元数据ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/metadata/${metadataId}`), {\n            method: 'DELETE',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`删除元数据失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('删除元数据错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 启用/禁用内置元数据\n * @param {String} datasetId - 知识库ID\n * @param {String} action - 操作，enable或disable\n * @returns {Promise<Object>} 操作结果\n */\nexport const toggleBuiltInMetadata = async (datasetId, action) => {\n    if (!datasetId || !action) {\n        throw new Error('知识库ID和操作类型不能为空');\n    }\n\n    if (action !== 'enable' && action !== 'disable') {\n        throw new Error('操作类型只能是enable或disable');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/metadata/built-in/${action}`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`${action === 'enable' ? '启用' : '禁用'}内置元数据失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error(`${action === 'enable' ? '启用' : '禁用'}内置元数据错误:`, error);\n        throw error;\n    }\n};\n\n/**\n * 更新文档元数据\n * @param {String} datasetId - 知识库ID\n * @param {Array} operationData - 操作数据\n * @returns {Promise<Object>} 更新结果\n */\nexport const updateDocumentsMetadata = async (datasetId, operationData) => {\n    if (!datasetId) {\n        throw new Error('知识库ID不能为空');\n    }\n\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl(`/datasets/${datasetId}/documents/metadata`), {\n            method: 'POST',\n            headers: getDatasetApiHeaders(),\n            body: JSON.stringify({ operation_data: operationData }),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`更新文档元数据失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('更新文档元数据错误:', error);\n        throw error;\n    }\n};\n\n/**\n * 获取知识库配置选项\n * @returns {Promise<Object>} 配置选项\n */\nexport const getDatasetConfigOptions = async () => {\n    const { signal } = createRequestController();\n\n    try {\n        const response = await fetch(getDatasetApiUrl('/datasets/config-options'), {\n            method: 'GET',\n            headers: getDatasetApiHeaders(),\n            signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`获取知识库配置选项失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('获取知识库配置选项错误:', error);\n        throw error;\n    }\n}; "],"names":["API_CONFIG","createApiUrl","path","customBaseUrl","urlString","createRequestController","controller","signal","error","getDatasetApiUrl","getDatasetApiHeaders","getDatasetList","options","page","limit","url","response","getDocumentList","datasetId","keyword","createDocumentByFile","formData","getDocumentIndexingStatus","batch"],"mappings":"AAQO,MAAMA,EAAa,CACtB,QAAS,UACT,OAAQ,+BACR,eAAgB,+BAChB,cAAe,kCACnB,EAQaC,EAAe,CAACC,EAAMC,IAAkB,CAEjD,MAAMC,EAAY,GADFD,CACY,GAAGD,CAAI,GAEnC,OADsBE,EAAU,WAAW,SAAS,GAAKA,EAAU,WAAW,UAAU,EACjE,IAAI,IAAIA,CAAS,EAAI,IAAI,IAAIA,EAAW,OAAO,SAAS,MAAM,CACzF,ECfaC,EAA0B,IAAM,CACzC,MAAMC,EAAa,IAAI,gBACjBC,EAASD,EAAW,OAkB1B,MAAO,CACH,WAAAA,EACA,OAAAC,EACA,aAlBiB,IAAM,CAEvB,GAAKD,EAAW,OAAO,QASnB,QAAQ,IAAI,gBAAgB,MAR5B,IAAI,CACA,QAAQ,IAAI,UAAU,EACtBA,EAAW,MAAK,EAChB,QAAQ,IAAI,QAAQ,CACvB,OAAQE,EAAO,CACZ,QAAQ,MAAM,WAAYA,CAAK,CAClC,CAIb,CAMA,CACA,ECtBMC,EAAoBP,GACfD,EAAaC,EAAMF,EAAW,OAAO,EAAE,SAAU,EAOtDU,EAAuB,KAClB,CACH,eAAgB,mBAChB,cAAiB,UAAUV,EAAW,aAAa,EACtD,GAUQW,EAAiB,MAAOC,EAAU,KAAO,CAClD,KAAM,CAAE,KAAAC,EAAO,EAAG,MAAAC,EAAQ,EAAI,EAAGF,EAC3B,CAAE,OAAAL,CAAQ,EAAGF,EAAyB,EAE5C,GAAI,CACA,MAAMU,EAAM,IAAI,IAAIN,EAAiB,WAAW,CAAC,EACjDM,EAAI,aAAa,OAAO,OAAQF,CAAI,EACpCE,EAAI,aAAa,OAAO,QAASD,CAAK,EAEtC,MAAME,EAAW,MAAM,MAAMD,EAAI,SAAQ,EAAI,CACzC,OAAQ,MACR,QAASL,EAAsB,EAC/B,OAAAH,CACZ,CAAS,EAED,GAAI,CAACS,EAAS,GACV,MAAM,IAAI,MAAM,cAAcA,EAAS,MAAM,EAAE,EAGnD,OAAO,MAAMA,EAAS,KAAM,CAC/B,OAAQR,EAAO,CACZ,cAAQ,MAAM,aAAcA,CAAK,EAC3BA,CACd,CACA,EAkHaS,EAAkB,MAAOC,EAAWN,EAAU,KAAO,CAC9D,GAAI,CAACM,EACD,MAAM,IAAI,MAAM,WAAW,EAG/B,KAAM,CAAE,KAAAL,EAAO,EAAG,MAAAC,EAAQ,GAAI,QAAAK,CAAO,EAAKP,EACpC,CAAE,OAAAL,CAAQ,EAAGF,EAAyB,EAE5C,GAAI,CACA,MAAMU,EAAM,IAAI,IAAIN,EAAiB,aAAaS,CAAS,YAAY,CAAC,EACxEH,EAAI,aAAa,OAAO,OAAQF,CAAI,EACpCE,EAAI,aAAa,OAAO,QAASD,CAAK,EAClCK,GACAJ,EAAI,aAAa,OAAO,UAAWI,CAAO,EAG9C,MAAMH,EAAW,MAAM,MAAMD,EAAI,SAAQ,EAAI,CACzC,OAAQ,MACR,QAASL,EAAsB,EAC/B,OAAAH,CACZ,CAAS,EAED,GAAI,CAACS,EAAS,GACV,MAAM,IAAI,MAAM,aAAaA,EAAS,MAAM,EAAE,EAGlD,OAAO,MAAMA,EAAS,KAAM,CAC/B,OAAQR,EAAO,CACZ,cAAQ,MAAM,YAAaA,CAAK,EAC1BA,CACd,CACA,EA8CaY,EAAuB,MAAOF,EAAWG,IAAa,CAC/D,GAAI,CAACH,EACD,MAAM,IAAI,MAAM,WAAW,EAG/B,KAAM,CAAE,OAAAX,CAAQ,EAAGF,EAAyB,EAE5C,GAAI,CACA,MAAMW,EAAW,MAAM,MAAMP,EAAiB,aAAaS,CAAS,0BAA0B,EAAG,CAC7F,OAAQ,OACR,QAAS,CACL,cAAiB,UAAUlB,EAAW,aAAa,EACtD,EACD,KAAMqB,EACN,OAAAd,CACZ,CAAS,EAED,GAAI,CAACS,EAAS,GACV,MAAM,IAAI,MAAM,eAAeA,EAAS,MAAM,EAAE,EAGpD,OAAO,MAAMA,EAAS,KAAM,CAC/B,OAAQR,EAAO,CACZ,cAAQ,MAAM,cAAeA,CAAK,EAC5BA,CACd,CACA,EA4Eac,EAA4B,MAAOJ,EAAWK,IAAU,CACjE,GAAI,CAACL,GAAa,CAACK,EACf,MAAM,IAAI,MAAM,eAAe,EAGnC,KAAM,CAAE,OAAAhB,CAAQ,EAAGF,EAAyB,EAE5C,GAAI,CACA,MAAMW,EAAW,MAAM,MAAMP,EAAiB,aAAaS,CAAS,cAAcK,CAAK,kBAAkB,EAAG,CACxG,OAAQ,MACR,QAASb,EAAsB,EAC/B,OAAAH,CACZ,CAAS,EAED,GAAI,CAACS,EAAS,GACV,MAAM,IAAI,MAAM,eAAeA,EAAS,MAAM,EAAE,EAGpD,OAAO,MAAMA,EAAS,KAAM,CAC/B,OAAQR,EAAO,CACZ,cAAQ,MAAM,cAAeA,CAAK,EAC5BA,CACd,CACA"}