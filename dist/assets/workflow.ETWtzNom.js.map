{"version":3,"file":"workflow.ETWtzNom.js","sources":["../../static/api/workflow.js"],"sourcesContent":["/**\n * 工作流API模块 - 处理无会话工作流调用\n */\n\n// 导入API配置\nimport { API_CONFIG, createApiUrl } from './config.js';\n\n/**\n * 执行工作流\n * @param {Object} inputs - 输入变量，如{content: \"要处理的内容\"}\n * @param {String} responseMode - 响应模式：'streaming'或'blocking'\n * @param {Object} options - 其他选项\n * @returns {Promise} 请求Promise\n */\nexport const runWorkflow = async (inputs = {}, responseMode = 'streaming', options = {}) => {\n    try {\n        const userId = options.userId || 'default-user';\n        const workflowId = options.workflowId || '';\n\n        // 使用工具函数创建URL\n        const url = createApiUrl('/workflows/run');\n\n        // 构建请求体\n        const requestBody = {\n            inputs: inputs,\n            response_mode: responseMode,\n            user: userId\n        };\n\n        console.log('[Workflow] 开始执行工作流:', {\n            inputs,\n            responseMode,\n            userId\n        });\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${API_CONFIG.apiKey}`\n            },\n            body: JSON.stringify(requestBody),\n            signal: options.signal\n        });\n\n        if (!response.ok) {\n            throw new Error(`工作流请求失败: ${response.status}`);\n        }\n\n        return response;\n    } catch (error) {\n        console.error('执行工作流失败:', error);\n        throw error;\n    }\n};\n\n/**\n * 处理工作流流式响应\n * @param {Promise} responsePromise - 响应Promise\n * @param {Object} callbacks - 回调函数对象\n */\nexport const handleWorkflowStreamResponse = async (responsePromise, callbacks = {}) => {\n    const {\n        onStart,\n        onNodeStart,\n        onNodeFinish,\n        onFinish,\n        onOutput,\n        onError,\n        onComplete,\n        onTTSMessage,\n        onTTSMessageEnd\n    } = callbacks;\n\n    try {\n        // 检查responsePromise是否已经被中断\n        if (responsePromise.signal && responsePromise.signal.aborted) {\n            console.log('[Workflow] 请求已中断');\n            onComplete?.(false, '请求已中断');\n            return;\n        }\n\n        const response = await responsePromise;\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error('[Workflow] API请求失败:', response.status, errorText);\n            throw new Error(`API请求失败: ${response.status} ${errorText}`);\n        }\n\n        console.log('[Workflow] 开始处理流式响应');\n\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n        let workflowRunId = null;\n        let taskId = null;\n\n        // 添加错误捕获包装\n        try {\n            while (true) {\n                // 检查是否请求已被中断\n                if (responsePromise.signal && responsePromise.signal.aborted) {\n                    console.log('[Workflow] 检测到请求中断信号，停止处理流');\n                    break;\n                }\n\n                const { done, value } = await reader.read();\n\n                if (done) {\n                    console.log('[Workflow] 流读取完成');\n                    break;\n                }\n\n                // 解码接收到的数据\n                buffer += decoder.decode(value, { stream: true });\n\n                // 处理缓冲区中的数据行\n                const lines = buffer.split('\\n\\n');\n                buffer = lines.pop() || ''; // 最后一行可能不完整，保留到下一次\n\n                for (const line of lines) {\n                    if (!line.trim() || !line.startsWith('data: ')) continue;\n\n                    try {\n                        const data = JSON.parse(line.substring(6));\n                        // 保存工作流运行ID和任务ID\n                        if (data.workflow_run_id && !workflowRunId) {\n                            workflowRunId = data.workflow_run_id;\n                        }\n\n                        if (data.task_id && !taskId) {\n                            taskId = data.task_id;\n                            // 使用回调通知上层组件\n                            if (callbacks.onTaskIdChange) {\n                                callbacks.onTaskIdChange(taskId);\n                            }\n                        }\n\n                        // 处理不同类型的事件\n                        if (data.event === 'workflow_started') {\n                            console.log('%c[Workflow] 收到工作流开始事件: workflow_started', 'color: #4CAF50; font-weight: bold;');\n                            onStart?.(data.data);\n                        } else if (data.event === 'node_started') {\n                            console.log('%c[Workflow] 收到节点开始事件: node_started', 'color: #4CAF50; font-weight: bold;');\n                            console.log('%c[Workflow Node Started]', 'color: #2196F3; font-weight: bold;', {\n                                title: data.data?.title\n                            });\n                            onNodeStart?.(data.data);\n                        } else if (data.event === 'node_finished') {\n                            console.log('%c[Workflow] 收到节点完成事件: node_finished', 'color: #4CAF50; font-weight: bold;');\n                            onNodeFinish?.(data.data);\n                        } else if (data.event === 'workflow_finished') {\n                            console.log('%c[Workflow] 收到工作流完成事件: workflow_finished', 'color: #4CAF50; font-weight: bold;');\n                            // 处理工作流完成事件\n                            onFinish?.(data.data);\n\n                            // 如果有输出内容，调用输出回调\n                            if (data.data && data.data.outputs) {\n                                onOutput?.(data.data.outputs);\n                            }\n                        } else if (data.event === 'tts_message') {\n                            console.log('%c[Workflow] 收到TTS事件: tts_message', 'color: #4CAF50; font-weight: bold;');\n                            onTTSMessage?.(data);\n                        } else if (data.event === 'tts_message_end') {\n                            console.log('%c[Workflow] 收到TTS结束事件: tts_message_end', 'color: #4CAF50; font-weight: bold;');\n                            onTTSMessageEnd?.(data);\n                        } else if (data.event === 'error') {\n                            console.error('%c[Workflow] 收到错误事件: error', 'color: #F44336; font-weight: bold;', data);\n                            onError?.(data.message || '工作流处理错误');\n                        } else if (data.event === 'ping') {\n                            console.log('%c[Workflow] 收到ping事件', 'color: #607D8B; font-style: italic;');\n                            // 忽略ping事件\n                        }\n                    } catch (e) {\n                        console.error('%c[Workflow] 解析流数据失败:', 'color: #F44336; font-weight: bold;', e);\n                    }\n                }\n            }\n        } catch (streamError) {\n            // 处理流处理过程中的错误\n            console.error('[Workflow] 流处理过程中出错:', streamError);\n            const errorMsg = streamError.message || '';\n\n            if (streamError.name === 'AbortError' ||\n                errorMsg.includes('aborted') ||\n                errorMsg.includes('abort')) {\n                console.log('[Workflow] 请求被中断');\n                onComplete?.(false, '请求处理过程已中断');\n                return;\n            }\n            throw streamError;\n        } finally {\n            // 确保释放资源\n            try {\n                reader.releaseLock();\n                console.log('[Workflow] 读取器已释放');\n            } catch (e) {\n                console.warn('[Workflow] 释放读取锁时出错:', e);\n            }\n        }\n\n        console.log('[Workflow] 流处理完成');\n        onComplete?.(true);\n    } catch (error) {\n        console.error('[Workflow] 流式请求错误:', error);\n\n        // 判断是否是AbortError（请求被中断）\n        if (error.name === 'AbortError' ||\n            error.message.includes('aborted')) {\n            console.log('[Workflow] 请求中断错误');\n            onComplete?.(false, '请求已中断');\n        } else {\n            console.error('[Workflow] 请求失败错误');\n            onError?.(error.message || '请求失败');\n            onComplete?.(false, error.message);\n        }\n    }\n};\n\n/**\n * 封装的工作流执行方法\n * @param {Object} inputs - 输入变量\n * @param {Object} callbacks - 回调函数\n * @param {Object} options - 其他选项\n * @returns {Object} 请求结果\n */\nexport const executeWorkflow = async (inputs = {}, callbacks = {}, options = {}) => {\n    try {\n        const userId = options.userId || 'default-user';\n        const responseMode = options.responseMode || 'streaming';\n\n        console.log('[Workflow] 开始工作流请求', {\n            inputs,\n            userId,\n            responseMode,\n            hasSignal: !!options.signal\n        });\n\n        // 发送请求\n        const responsePromise = runWorkflow(\n            inputs,\n            responseMode,\n            {\n                userId,\n                signal: options.signal\n            }\n        );\n\n        // 如果是阻塞模式，直接返回结果\n        if (responseMode === 'blocking') {\n            const response = await responsePromise;\n            const result = await response.json();\n            callbacks.onOutput?.(result.data?.outputs);\n            callbacks.onComplete?.(true);\n            return { success: true, data: result };\n        }\n\n        // 处理流式响应\n        try {\n            console.log('[Workflow] 开始处理流式响应');\n            await handleWorkflowStreamResponse(responsePromise, callbacks);\n            console.log('[Workflow] 流式响应处理成功');\n            return { success: true };\n        } catch (streamError) {\n            console.error('[Workflow] 流处理过程中出错:', streamError);\n\n            if (streamError.name === 'AbortError' ||\n                streamError.message?.includes('aborted')) {\n                console.log('[Workflow] 流处理被中断');\n                callbacks.onComplete?.(false, '请求已中断');\n                return { success: false, aborted: true, error: streamError };\n            }\n\n            console.error('[Workflow] 流处理失败:', streamError.message || '未知错误');\n            callbacks.onError?.(streamError.message || '流处理失败');\n            callbacks.onComplete?.(false, streamError.message);\n            return { success: false, error: streamError };\n        }\n    } catch (error) {\n        console.error('[Workflow] 工作流请求错误:', error);\n\n        if (error.name === 'AbortError' ||\n            error.message?.includes('aborted')) {\n            console.log('[Workflow] 工作流请求被中断');\n            callbacks.onComplete?.(false, '请求已中断');\n            return { success: false, aborted: true, error };\n        }\n\n        console.error('[Workflow] 工作流请求失败:', error.message || '未知错误');\n        callbacks.onError?.(error.message || '请求失败');\n        callbacks.onComplete?.(false, error.message);\n        return { success: false, error };\n    }\n};\n\n/**\n * 停止工作流执行\n * @param {String} taskId - 任务ID\n * @param {String} userId - 用户ID\n * @returns {Promise} 请求Promise\n */\nexport const stopWorkflowExecution = async (taskId, userId = 'default-user') => {\n    try {\n        if (!taskId) {\n            throw new Error('任务ID不能为空');\n        }\n\n        // 使用工具函数创建URL\n        const url = createApiUrl(`/workflows/tasks/${taskId}/stop`);\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${API_CONFIG.apiKey}`\n            },\n            body: JSON.stringify({ user: userId })\n        });\n\n        if (!response.ok) {\n            throw new Error(`停止工作流请求失败: ${response.status}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('停止工作流执行失败:', error);\n        throw error;\n    }\n};\n\n/**\n * 自动生成文章标题（使用特定工作流）\n * @param {String} content - 文章内容\n * @param {Object} callbacks - 回调函数\n * @param {Object} options - 其他选项\n * @returns {Object} 请求结果\n */\nexport const generateArticleTitle = async (content, callbacks = {}, options = {}) => {\n    try {\n        const userId = options.userId || 'default-user';\n        const responseMode = options.responseMode || 'streaming';\n\n        // 使用特定的工作流API密钥，而不是通用API密钥\n        const workflowApiKey = 'app-6aRhLAp4zAppCJus5ViMgOsh';  // 直接使用固定的工作流API密钥\n\n        // 构建输入变量\n        const inputs = {\n            content: content  // 工作流需要的输入变量是content\n        };\n\n        console.log('[WorkflowTitle] 开始执行标题生成工作流:', {\n            contentLength: content.length,\n            responseMode,\n            userId\n        });\n\n        // 使用工具函数创建URL\n        const url = createApiUrl('/workflows/run');\n\n        // 构建请求体\n        const requestBody = {\n            inputs: inputs,\n            response_mode: responseMode,\n            user: userId\n        };\n\n        console.log('[WorkflowTitle] 发送工作流请求:', {\n            url: url.toString(),\n            workflowApiKey: workflowApiKey.substring(0, 10) + '...',\n            requestBody\n        });\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${workflowApiKey}`  // 使用工作流专用密钥\n            },\n            body: JSON.stringify(requestBody),\n            signal: options.signal\n        });\n\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error('[WorkflowTitle] 请求失败:', response.status, errorText);\n            throw new Error(`标题生成工作流请求失败: ${response.status} - ${errorText}`);\n        }\n\n        // 如果是阻塞模式，直接返回结果\n        if (responseMode === 'blocking') {\n            const result = await response.json();\n            console.log('[WorkflowTitle] 收到阻塞模式响应:', result);\n\n            // 提取标题，过滤思考内容\n            let title = result.data?.outputs?.text || '';\n            title = extractFinalTitle(title);\n\n            console.log('[WorkflowTitle] 最终生成的标题:', title);\n\n            if (title) {\n                callbacks.onOutput?.({ text: title });\n            } else {\n                console.warn('[WorkflowTitle] 未从响应中找到有效标题');\n                callbacks.onError?.('未能生成有效标题');\n            }\n\n            callbacks.onComplete?.(true);\n            return { success: true, data: result, title };\n        }\n\n        // 处理流式响应\n        try {\n            console.log('[WorkflowTitle] 开始处理流式响应');\n\n            // 创建自定义回调函数，专注于提取标题\n            const titleCallbacks = {\n                ...callbacks,\n                onOutput: (outputs) => {\n                    let title = outputs.text || '';\n                    // 过滤掉思考内容\n                    title = extractFinalTitle(title);\n\n                    console.log('[WorkflowTitle] 获得过滤后的标题:', title);\n                    if (title) {\n                        callbacks.onOutput?.({ text: title });\n                    }\n                },\n                onFinish: (data) => {\n                    if (callbacks.onFinish) {\n                        callbacks.onFinish(data);\n                    }\n\n                    // 如果输出中包含思考部分，再次过滤一次\n                    if (data && data.outputs && data.outputs.text) {\n                        let title = data.outputs.text;\n                        title = extractFinalTitle(title);\n\n                        if (title && title !== data.outputs.text) {\n                            console.log('[WorkflowTitle] 工作流完成后过滤标题:', title);\n                            callbacks.onOutput?.({ text: title });\n                        }\n                    }\n                }\n            };\n\n            await handleWorkflowStreamResponse(response, titleCallbacks);\n            console.log('[WorkflowTitle] 流式响应处理成功');\n            return { success: true };\n        } catch (streamError) {\n            console.error('[WorkflowTitle] 流处理过程中出错:', streamError);\n\n            if (streamError.name === 'AbortError' ||\n                streamError.message?.includes('aborted')) {\n                console.log('[WorkflowTitle] 流处理被中断');\n                callbacks.onComplete?.(false, '请求已中断');\n                return { success: false, aborted: true, error: streamError };\n            }\n\n            console.error('[WorkflowTitle] 流处理失败:', streamError.message || '未知错误');\n            callbacks.onError?.(streamError.message || '标题生成失败');\n            callbacks.onComplete?.(false, streamError.message);\n            return { success: false, error: streamError };\n        }\n    } catch (error) {\n        console.error('[WorkflowTitle] 标题生成请求错误:', error);\n\n        if (error.name === 'AbortError' ||\n            error.message?.includes('aborted')) {\n            console.log('[WorkflowTitle] 标题生成请求被中断');\n            callbacks.onComplete?.(false, '请求已中断');\n            return { success: false, aborted: true, error };\n        }\n\n        console.error('[WorkflowTitle] 标题生成请求失败:', error.message || '未知错误');\n        callbacks.onError?.(error.message || '请求失败');\n        callbacks.onComplete?.(false, error.message);\n        return { success: false, error };\n    }\n};\n\n/**\n * 从返回的文本中提取最终标题，过滤掉思考过程\n * @param {String} text - 包含可能的思考过程的文本\n * @returns {String} 提取的最终标题\n */\nfunction extractFinalTitle(text) {\n    if (!text) return '';\n\n    // 过滤掉<think>...</think>思考部分\n    const thinkRegex = /<think>[\\s\\S]*?<\\/think>/;\n    text = text.replace(thinkRegex, '');\n\n    // 移除开头和结尾的空白字符和换行符\n    text = text.trim();\n\n    console.log('[WorkflowTitle] 过滤后的标题:', text);\n    return text;\n} "],"names":["handleWorkflowStreamResponse","responsePromise","callbacks","onStart","onNodeStart","onNodeFinish","onFinish","onOutput","onError","onComplete","onTTSMessage","onTTSMessageEnd","response","errorText","reader","decoder","buffer","workflowRunId","taskId","done","value","lines","line","data","_a","streamError","errorMsg","e","error","generateArticleTitle","content","options","userId","responseMode","workflowApiKey","inputs","url","createApiUrl","requestBody","result","title","_b","extractFinalTitle","_c","_d","_e","titleCallbacks","outputs","_f","_g","_h","_i","_j","_k","_l","_m","text","thinkRegex"],"mappings":"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"}